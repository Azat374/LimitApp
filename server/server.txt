==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\.env.example ====
#SQLALCHEMY_DATABASE_URI=sqlite:///database/math_checker.db
SECRET_KEY=23e629b053aeda6ff423b58a99f861cecd1670e05af7bb9ea55757f419e2a0dcdab40e36e772fbf55ef0ba5533527e4360ad2c25b740336049a9d30667ca126c
DATABASE_PATH = os.path.join(BASE_DIR, "database", "math_checker.db")
SQLALCHEMY_DATABASE_URI = "sqlite:///" + DATABASE_PATH



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\app.py ====
from flask import Flask
from flask_cors import CORS
from config import Config
from models import db
from utils.Auth.auth import auth_bp
from tasks import tasks_bp
from solutions import solutions_bp
from reports import reports_bp

app = Flask(__name__)
app.config.from_object(Config)
CORS(app)

db.init_app(app)

# –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è Blueprints
app.register_blueprint(auth_bp)
app.register_blueprint(tasks_bp)
app.register_blueprint(solutions_bp)
app.register_blueprint(reports_bp)

# –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü, –µ—Å–ª–∏ –∏—Ö –µ—â—ë –Ω–µ—Ç
with app.app_context():
    db.create_all()

if __name__ == "__main__":
    app.run(debug=True)



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\checker.py ====
import sympy as sp

def safe_sympify(expr):
    """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –≤ sympy-—Ñ–æ—Ä–º–∞—Ç."""
    try:
        if expr == "LIMIT":
            # –ï—Å–ª–∏ –ø—Ä–∏—Ö–æ–¥–∏—Ç LIMIT, —Å—Ä–∞–∑—É –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —á—Ç–æ-—Ç–æ
            # –ù–æ –ª—É—á—à–µ –≤–æ–æ–±—â–µ –Ω–µ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –µ–≥–æ –∫–∞–∫ expr :)
            return sp.Integer(0)  # –∑–∞–≥–ª—É—à–∫–∞
        expr = expr.replace("e^{", "exp(").replace(r"\ln", "log")
        return sp.sympify(expr)
    except Exception as e:
        raise ValueError(f"–û—à–∏–±–∫–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –≤—ã—Ä–∞–∂–µ–Ω–∏—è '{expr}': {e}")

def check_algebraic_step(prev_expr_str, curr_expr_str, tolerance=1e-6):
    try:
        # –ï—Å–ª–∏ –≤ prev_expr_str = "LIMIT", –º–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É
        if prev_expr_str == "LIMIT":
            return {"is_correct": True, "error_type": None, "hint": "LIMIT –∫–∞–∫ –ø—Ä–µ–¥—ã–¥—É—â–∏–π —à–∞–≥ –ø—Ä–æ–ø—É—â–µ–Ω."}

        prev_expr = sp.simplify(safe_sympify(prev_expr_str))
        curr_expr = sp.simplify(safe_sympify(curr_expr_str))
        if prev_expr.equals(curr_expr):
            return {"is_correct": True, "error_type": None, "hint": ""}
        # –î–æ–ø.—á–∏—Å–ª–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
        for val in [1, 2, 3]:
            if abs(prev_expr.subs({'x': val}) - curr_expr.subs({'x': val})) > tolerance:
                return {
                    "is_correct": False,
                    "error_type": "algebraic_error",
                    "hint": "–û—à–∏–±–∫–∞ –≤ –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏—Ö –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è—Ö. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ –∏–ª–∏ –≤—ã–Ω–µ—Å–µ–Ω–∏–µ –º–Ω–æ–∂–∏—Ç–µ–ª—è."
                }
        return {"is_correct": True, "error_type": None, "hint": ""}
    except Exception as e:
        return {"is_correct": False, "error_type": "parse_error", "hint": f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞: {str(e)}"}

def check_limit(last_expr_str, expected_limit_str):
    try:
        x = sp.Symbol('x')
        last_expr = safe_sympify(last_expr_str)
        computed_limit = sp.limit(last_expr, x, sp.oo)
        expected_limit = safe_sympify(expected_limit_str)
        if sp.simplify(computed_limit - expected_limit) == 0:
            return {"is_correct": True, "computed_limit": computed_limit, "error_type": None, "hint": ""}
        else:
            return {
                "is_correct": False,
                "computed_limit": computed_limit,
                "error_type": "limit_error",
                "hint": f"–û–∂–∏–¥–∞–µ–º—ã–π –ø—Ä–µ–¥–µ–ª: {expected_limit}"
            }
    except Exception as e:
        return {
            "is_correct": False,
            "error_type": "limit_parse_error",
            "hint": f"–û—à–∏–±–∫–∞ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –ø—Ä–µ–¥–µ–ª–∞: {str(e)}"
        }



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\config.py ====
import os

BASE_DIR = os.path.abspath(os.path.dirname(__file__))
DATABASE_PATH = os.path.join(BASE_DIR, "database", "math_checker.db")

# –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å
print("DATABASE_PATH:", DATABASE_PATH)  # üîπ –í—ã–≤–æ–¥ –ø—É—Ç–∏ –≤ –∫–æ–Ω—Å–æ–ª—å

SQLALCHEMY_DATABASE_URI = f"sqlite:///{DATABASE_PATH}"
SQLALCHEMY_TRACK_MODIFICATIONS = False
import os
from dotenv import load_dotenv

load_dotenv()

BASE_DIR = os.path.abspath(os.path.dirname(__file__))
DATABASE_PATH = os.path.join(BASE_DIR, "database", "math_checker.db")

class Config:
    SECRET_KEY = os.getenv('SECRET_KEY', '23e629b053aeda6ff423b58a99f861cecd1670e05af7bb9ea55757f419e2a0dcdab40e36e772fbf55ef0ba5533527e4360ad2c25b740336049a9d30667ca126c')
    SQLALCHEMY_DATABASE_URI = f"sqlite:///{DATABASE_PATH}"
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    DEBUG = True



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\models.py ====
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

db = SQLAlchemy()

class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    firstname = db.Column(db.String(100), nullable=False)
    lastname = db.Column(db.String(100), nullable=False)
    username = db.Column(db.String(100), unique=True, nullable=False)
    email = db.Column(db.String(150), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)
    bio = db.Column(db.Text, default="")
    image = db.Column(db.String(300), default="")
    role = db.Column(db.String(50), default="student")  # –∏–ª–∏ "admin"
    chat_history = db.Column(db.Text)  # –º–æ–∂–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å JSON –∫–∞–∫ —Å—Ç—Ä–æ–∫—É

    solutions = db.relationship('Solution', backref='user', lazy=True)

class Task(db.Model):
    __tablename__ = 'tasks'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    description = db.Column(db.Text)
    expression = db.Column(db.String(500), nullable=False)  # –∏—Å—Ö–æ–¥–Ω–æ–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ
    limitVar = db.Column(db.String(50), nullable=False)      # –Ω–∞–ø—Ä–∏–º–µ—Ä "x->‚àû"
    expected_limit = db.Column(db.String(100), nullable=False)

    solutions = db.relationship('Solution', backref='task', lazy=True)

class Solution(db.Model):
    __tablename__ = 'solutions'
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    task_id = db.Column(db.Integer, db.ForeignKey('tasks.id'), nullable=False)
    status = db.Column(db.String(50), default="in_progress")  # in_progress, completed, error
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    steps = db.relationship('Step', backref='solution', lazy=True)

class Step(db.Model):
    __tablename__ = 'steps'
    id = db.Column(db.Integer, primary_key=True)
    solution_id = db.Column(db.Integer, db.ForeignKey('solutions.id'), nullable=False)
    step_number = db.Column(db.Integer, nullable=False)
    input_expr = db.Column(db.String(500), nullable=False)
    is_correct = db.Column(db.Boolean, default=True)
    error_type = db.Column(db.String(100))
    hint = db.Column(db.String(300))



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\reports.py ====
from flask import Blueprint, request, send_file, jsonify
from models import db, Solution, User, Task, Step
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
import io
from datetime import datetime

reports_bp = Blueprint('reports', __name__, url_prefix='/api/reports')

@reports_bp.route('/pdf', methods=['POST'])
def generate_pdf_report():
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç PDF-–æ—Ç—á–µ—Ç —Å –∏—Å—Ç–æ—Ä–∏–µ–π —Ä–µ—à–µ–Ω–∏–π —Å—Ç—É–¥–µ–Ω—Ç–æ–≤, —Ä–∞–∑–±–æ—Ä–æ–º –æ—à–∏–±–æ–∫ –∏ –ø–æ–¥—Å–∫–∞–∑–∫–∞–º–∏.
    –û–∂–∏–¥–∞–µ—Ç—Å—è JSON —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏: period (–Ω–∞–ø—Ä–∏–º–µ—Ä, "2024-01-01:2024-02-01"),
    task_id –∏ student_id (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ).
    """
    data = request.json
    period = data.get("period")  # —Ñ–æ—Ä–º–∞—Ç "YYYY-MM-DD:YYYY-MM-DD"
    task_id = data.get("task_id")
    student_id = data.get("student_id")

    query = Solution.query
    if period:
        try:
            start_str, end_str = period.split(":")
            start_date = datetime.strptime(start_str, "%Y-%m-%d")
            end_date = datetime.strptime(end_str, "%Y-%m-%d")
            query = query.filter(Solution.created_at >= start_date, Solution.created_at <= end_date)
        except Exception as e:
            return jsonify({"message": "Invalid period format. Use YYYY-MM-DD:YYYY-MM-DD"}), 400
    if task_id:
        query = query.filter(Solution.task_id == task_id)
    if student_id:
        query = query.filter(Solution.user_id == student_id)

    solutions = query.all()

    # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è PDF —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º ReportLab
    buffer = io.BytesIO()
    p = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter
    y = height - 50
    p.setFont("Helvetica-Bold", 16)
    p.drawString(50, y, "–û—Ç—á–µ—Ç –ø–æ —Ä–µ—à–µ–Ω–∏—è–º —Å—Ç—É–¥–µ–Ω—Ç–æ–≤")
    y -= 30
    p.setFont("Helvetica", 12)
    for sol in solutions:
        user = sol.user
        task = sol.task
        p.drawString(50, y, f"–†–µ—à–µ–Ω–∏–µ ID: {sol.id} | –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user.username} | –ó–∞–¥–∞—á–∞: {task.title} | –°—Ç–∞—Ç—É—Å: {sol.status}")
        y -= 20
        for step in sorted(sol.steps, key=lambda s: s.step_number):
            text = f"–®–∞–≥ {step.step_number}: {step.input_expr} | –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ: {step.is_correct}"
            if not step.is_correct:
                text += f" | –û—à–∏–±–∫–∞: {step.error_type} | –ü–æ–¥—Å–∫–∞–∑–∫–∞: {step.hint}"
            p.drawString(70, y, text)
            y -= 15
            if y < 50:
                p.showPage()
                y = height - 50
        y -= 20
        if y < 50:
            p.showPage()
            y = height - 50
    p.save()
    buffer.seek(0)
    return send_file(buffer, as_attachment=True, download_name="report.pdf", mimetype="application/pdf")



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\requirements.txt ====
Flask
flask-cors
pymongo
python-dotenv
gunicorn
requests
google-generativeai
cloudinary
Flask-SQLAlchemy
reportlab
werkzeug
PyJWT
sympy


==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\routes.py ====
from flask import Flask, request, jsonify
from flask_cors import CORS
from models import db, Task, Solution, Step
from checker import check_step

app = Flask(__name__)
app.config.from_object("config.Config")
db.init_app(app)
CORS(app)

@app.route("/tasks", methods=["GET"])
def get_tasks():
    tasks = Task.query.all()
    return jsonify([{"id": t.id, "title": t.title, "description": t.description} for t in tasks])

@app.route("/tasks/<int:task_id>/start", methods=["POST"])
def start_solution(task_id):
    solution = Solution(task_id=task_id, status="in_progress")
    db.session.add(solution)
    db.session.commit()
    return jsonify({"solution_id": solution.id})

@app.route("/solutions/<int:solution_id>/check_step", methods=["POST"])
def check_solution_step(solution_id):
    data = request.json
    step_number = data.get("step_number")
    prev_expr = data.get("prev_expr", "")
    curr_expr = data.get("curr_expr", "")

    result = check_step(prev_expr, curr_expr)
    
    step = Step(solution_id=solution_id, step_number=step_number,
                input_expr=curr_expr, is_correct=result["is_correct"],
                error_type=result["error_type"], hint=result["hint"])
    
    db.session.add(step)
    db.session.commit()

    return jsonify(result)

@app.route("/solutions/<int:solution_id>/finish", methods=["POST"])
def finish_solution(solution_id):
    solution = Solution.query.get(solution_id)
    solution.status = "completed"
    db.session.commit()
    return jsonify({"message": "–†–µ—à–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!"})

if __name__ == "__main__":
    with app.app_context():
        db.create_all()
    app.run(debug=True)



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\solutions.py ====
from flask import Blueprint, request, jsonify
from models import db, Solution, Step, Task
from checker import check_algebraic_step, check_limit

solutions_bp = Blueprint('solutions', __name__, url_prefix='/api/solutions')

@solutions_bp.route('', methods=['GET'])
def get_solutions():
    # –≠–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –≤—Å–µ—Ö —Ä–µ—à–µ–Ω–∏–π (–¥–ª—è –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤)
    solutions = Solution.query.all()
    solutions_list = []
    for sol in solutions:
        steps = [{
            "step_number": s.step_number,
            "input_expr": s.input_expr,
            "is_correct": s.is_correct,
            "error_type": s.error_type,
            "hint": s.hint
        } for s in sol.steps]
        solutions_list.append({
            "id": sol.id,
            "user_id": sol.user_id,
            "task_id": sol.task_id,
            "status": sol.status,
            "created_at": sol.created_at,
            "steps": steps
        })
    return jsonify({"solutions": solutions_list}), 200

@solutions_bp.route('/<int:solution_id>/check_step', methods=['POST'])
def check_solution_step(solution_id):
    data = request.json
    step_number = data.get("step_number")
    prev_expr = data.get("prev_expr", "")
    curr_expr = data.get("curr_expr", "")
    if step_number is None:
        return jsonify({"message": "step_number is required"}), 400

    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞, –µ—Å–ª–∏ solution_id –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ –ë–î:
    solution = Solution.query.get(solution_id)
    if not solution:
        # –ú–æ–∂–Ω–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞—Ç—å —Ä–µ—à–µ–Ω–∏–µ –¥–ª—è –∑–∞–¥–∞—á–∏ c id=solution_id
        # –∏–ª–∏ –≤–µ—Ä–Ω—É—Ç—å –æ—à–∏–±–∫—É:
        return jsonify({"message": f"Solution with id={solution_id} not found"}), 404

    result = check_algebraic_step(prev_expr, curr_expr)
    new_step = Step(
        solution_id=solution_id,
        step_number=step_number,
        input_expr=curr_expr,
        is_correct=result["is_correct"],
        error_type=result["error_type"],
        hint=result["hint"]
    )
    db.session.add(new_step)
    db.session.commit()
    return jsonify(result), 200

@solutions_bp.route('/<int:solution_id>/finish', methods=['POST'])
def finish_solution(solution_id):
    solution = Solution.query.get(solution_id)
    if not solution:
        return jsonify({"message": "Solution not found"}), 404

    # –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥ ‚Äì –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–µ–¥–µ–ª–∞.
    steps = sorted(solution.steps, key=lambda s: s.step_number)
    if not steps:
        return jsonify({"message": "No steps found in solution"}), 400

    last_step = steps[-1]
    task = Task.query.get(solution.task_id)
    limit_result = check_limit(last_step.input_expr, task.expected_limit)
    if not limit_result.get("is_correct"):
        return jsonify({
            "success": False,
            "errors": [{
                "step": last_step.step_number,
                "error": "–ù–µ–≤–µ—Ä–Ω—ã–π –ø—Ä–µ–¥–µ–ª",
                "expected": str(task.expected_limit),
                "received": str(limit_result.get("computed_limit")),
                "hint": limit_result.get("hint")
            }]
        }), 200

    solution.status = "completed"
    db.session.commit()
    return jsonify({"message": f"–†–µ—à–µ–Ω–∏–µ –≤–µ—Ä–Ω–æ–µ, –ø—Ä–µ–¥–µ–ª = {limit_result.get('computed_limit')}"}), 200



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\tasks.py ====
from flask import Blueprint, request, jsonify
from models import db, Task

tasks_bp = Blueprint('tasks', __name__, url_prefix='/api/tasks')

@tasks_bp.route('', methods=['GET'])
def get_tasks():
    tasks = Task.query.all()
    tasks_list = []
    for t in tasks:
        tasks_list.append({
            "id": t.id,
            "title": t.title,
            "description": t.description,
            "expression": t.expression,
            "limitVar": t.limitVar,
            "expected_limit": t.expected_limit
        })
    return jsonify({"tasks": tasks_list}), 200

@tasks_bp.route('/<int:task_id>', methods=['GET'])
def get_task(task_id):
    """
    –î–æ–±–∞–≤–ª–µ–Ω–Ω—ã–π —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ–¥–Ω–æ–π –∑–∞–¥–∞—á–∏ –ø–æ ID.
    """
    task = Task.query.get(task_id)
    if not task:
        return jsonify({"message": "Task not found"}), 404
    return jsonify({
        "id": task.id,
        "title": task.title,
        "description": task.description,
        "expression": task.expression,
        "limitVar": task.limitVar,
        "expected_limit": task.expected_limit
    }), 200

@tasks_bp.route('', methods=['POST'])
def create_task():
    data = request.json
    required_fields = ['title', 'expression', 'limitVar', 'expected_limit']
    for field in required_fields:
        if field not in data:
            return jsonify({"message": f"{field} is required"}), 400

    new_task = Task(
        title=data['title'],
        description=data.get('description', ''),
        expression=data['expression'],
        limitVar=data['limitVar'],
        expected_limit=data['expected_limit']
    )
    db.session.add(new_task)
    db.session.commit()
    return jsonify({"message": "Task created successfully", "task_id": new_task.id}), 201

@tasks_bp.route('/<int:task_id>', methods=['PUT'])
def update_task(task_id):
    task = Task.query.get(task_id)
    if not task:
        return jsonify({"message": "Task not found"}), 404
    data = request.json
    task.title = data.get('title', task.title)
    task.description = data.get('description', task.description)
    task.expression = data.get('expression', task.expression)
    task.limitVar = data.get('limitVar', task.limitVar)
    task.expected_limit = data.get('expected_limit', task.expected_limit)
    db.session.commit()
    return jsonify({"message": "Task updated successfully"}), 200

@tasks_bp.route('/<int:task_id>', methods=['DELETE'])
def delete_task(task_id):
    task = Task.query.get(task_id)
    if not task:
        return jsonify({"message": "Task not found"}), 404
    db.session.delete(task)
    db.session.commit()
    return jsonify({"message": "Task deleted successfully"}), 200



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\utils\Auth\auth.py ====
from flask import Blueprint, request, jsonify
from werkzeug.security import generate_password_hash, check_password_hash
from models import db, User
import jwt
import datetime
from config import Config

auth_bp = Blueprint('auth', __name__, url_prefix='/api/auth')

@auth_bp.route('/signup', methods=['POST'])
def register():
    
    data = request.json
    required_fields = ['firstname', 'lastname', 'username', 'email', 'password']
    for field in required_fields:
        if field not in data:
            return jsonify({"message": f"{field} is required"}), 400

    if User.query.filter_by(username=data['username']).first():
        return jsonify({"message": "Username already exists"}), 400

    hashed_password = generate_password_hash(data['password'])
    new_user = User(
        firstname=data['firstname'],
        lastname=data['lastname'],
        username=data['username'],
        email=data['email'],
        password=hashed_password,
        bio=data.get('bio', ''),
        image=data.get('image', ''),
        role=data.get('role', 'student')
    )
    db.session.add(new_user)
    db.session.commit()

    return jsonify({"message": "User registered successfully"}), 201

@auth_bp.route('/login', methods=['POST'])
def login():
    data = request.json
    if 'username' not in data or 'password' not in data:
        return jsonify({"message": "Username and password are required"}), 400

    user = User.query.filter_by(username=data['username']).first()
    if user and check_password_hash(user.password, data['password']):
        token = jwt.encode({
            'user_id': user.id,
            'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=24)
        }, Config.SECRET_KEY, algorithm="HS256")
        return jsonify({
            "message": "Login successful",
            "token": token,
            "user": {
                "username": user.username,
                "firstname": user.firstname,
                "lastname": user.lastname,
                "email": user.email,
                "role": user.role
            }
        }), 200
    return jsonify({"message": "Invalid credentials"}), 401



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\utils\Auth\__init__.py ====



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\utils\Model\model.py ====
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

db = SQLAlchemy()

class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    firstname = db.Column(db.String(100), nullable=False)
    lastname = db.Column(db.String(100), nullable=False)
    username = db.Column(db.String(100), unique=True, nullable=False)
    email = db.Column(db.String(150), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)
    bio = db.Column(db.Text, default="")
    image = db.Column(db.String(300), default="")
    role = db.Column(db.String(50), default="student")  # –∏–ª–∏ "admin"
    chat_history = db.Column(db.Text)  # –º–æ–∂–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å JSON –∫–∞–∫ —Å—Ç—Ä–æ–∫—É

    solutions = db.relationship('Solution', backref='user', lazy=True)

class Task(db.Model):
    __tablename__ = 'tasks'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    description = db.Column(db.Text)
    expression = db.Column(db.String(500), nullable=False)  # –∏—Å—Ö–æ–¥–Ω–æ–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ
    limitVar = db.Column(db.String(50), nullable=False)      # –Ω–∞–ø—Ä–∏–º–µ—Ä "x->‚àû"
    expected_limit = db.Column(db.String(100), nullable=False)

    solutions = db.relationship('Solution', backref='task', lazy=True)

class Solution(db.Model):
    __tablename__ = 'solutions'
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    task_id = db.Column(db.Integer, db.ForeignKey('tasks.id'), nullable=False)
    status = db.Column(db.String(50), default="in_progress")  # in_progress, completed, error
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    steps = db.relationship('Step', backref='solution', lazy=True)

class Step(db.Model):
    __tablename__ = 'steps'
    id = db.Column(db.Integer, primary_key=True)
    solution_id = db.Column(db.Integer, db.ForeignKey('solutions.id'), nullable=False)
    step_number = db.Column(db.Integer, nullable=False)
    input_expr = db.Column(db.String(500), nullable=False)
    is_correct = db.Column(db.Boolean, default=True)
    error_type = db.Column(db.String(100))
    hint = db.Column(db.String(300))



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\utils\Model\__init__.py ====



